import crypto from "node:crypto";
import { EventAppConfig, EventGoal } from "@/lib/types";

// Deterministic hash to keep event + identity IDs stable across retries
const stableHash = (input: string) =>
  crypto.createHash("sha256").update(input).digest("hex").slice(0, 12);

export type EventGenerationInputs = {
  eventBasics: string;
  explicitEventName: string;
  eventDate: string;
  eventLocation: string;
  goals: string[];
  audience: string;
  relationshipIntent: string;
  tone: string;
};

export async function generateEventConfigFromInputs(
  inputs: EventGenerationInputs
): Promise<{ config: EventAppConfig; eventId: string }> {
  // ---------------------------------------------------------
  // REAL AI GENERATION via BAML
  // ---------------------------------------------------------

  // We import 'b' dynamically to avoid build crashes if sdk not fully set up
  const { b } = await import("@/lib/baml_client/baml_client");

  const bamlResult = await b.GenerateEventAppConfig(
    inputs.eventBasics || inputs.explicitEventName,
    inputs.eventDate,
    inputs.eventLocation,
    inputs.goals,
    inputs.audience,
    inputs.relationshipIntent,
    "standard", // sessionShape
    "high", // matchmakingAppetite
    "standard", // tools
    inputs.tone
  );

  // Transform BAML result to Application Type
  const config: EventAppConfig = {
    id: "gen_" + Math.random().toString(36).substring(7),
    eventId: "evt_" + Math.random().toString(36).substring(7),
    version: 1,
    createdAt: new Date(),
    updatedAt: new Date(),
    attendeeProfileFields: [], // Defaults
    primaryGoals: bamlResult.primaryGoals as EventGoal[],
    matchmakingConfig: {
      ...bamlResult.matchmakingConfig,
      // Ensure numbers are numbers
      meetingDurations:
        bamlResult.matchmakingConfig.meetingDurations.map(Number),
    },
    sessionConfig: {
      ...bamlResult.sessionConfig,
      maxConcurrentSessions: Number(
        bamlResult.sessionConfig.maxConcurrentSessions
      ),
    },
    engagementConfig: bamlResult.engagementConfig,
    relationshipFeatures: bamlResult.relationshipFeatures,
    branding: bamlResult.branding,
    designNotes: bamlResult.designNotes,

    // Default / Stubbed Fields (not generated by BAML yet)
    ticketing: {
      registrationOpen: true,
      skus: [],
    },
    venueConstraints: {
      maxCapacity: 500,
      roomConstraints: {},
      accessibilityFeatures: [],
    },
    sponsors: {
      tiers: [],
      assets: {},
    },
    legal: {
      photoConsentRequired: true,
    },
    contentGuardrails: {
      brandVoiceGuidelines: "",
      tabooTopics: [],
      sensitiveTopics: [],
    },

    content: {
      eventName: bamlResult.content.eventName,
      tagline: bamlResult.content.tagline,
      date: bamlResult.content.date,
      location: bamlResult.content.location,
      speakers: bamlResult.content.speakers.map((s) => ({
        ...s,
        did: `did:rhiz:${s.name.replace(/\s+/g, "").toLowerCase()}`,
        handle: s.name.replace(/\s+/g, "").toLowerCase(),
      })),
      schedule: bamlResult.content.schedule.map((s) => ({
        ...s,
        eventId: "evt1", // temp
        startTime: new Date(), // Mock date since BAML gives string time
        endTime: new Date(),
        format: s.isWide ? "keynote" : "session",
        speakers: [s.speakerName],
      })),
      sampleAttendees: bamlResult.content.sampleAttendees.map((a) => ({
        person_id: a.id || `p_${Math.random()}`,
        owner_id: "system",
        legal_name: a.name,
        tags: a.interests,
        imageFromUrl: a.imageUrl,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        emails: [],
        phones: [],
        social_handles: {},
      })),
    },
  };

  // MERGE USER INPUTS (Override defaults if needed)
  if (inputs.explicitEventName) {
    if (config.content) config.content.eventName = inputs.explicitEventName;
  }

  // Generate stable ID
  const eventFingerprint = `${inputs.eventBasics}|${inputs.eventDate}|${
    inputs.eventLocation
  }|${inputs.goals.join(",")}|${inputs.audience}|${inputs.tone}`;
  const eventId = `event_${stableHash(eventFingerprint)}`;

  // Update IDs
  config.eventId = eventId;
  if (config.content) {
    config.content.schedule.forEach((s) => (s.eventId = eventId));
  }

  return { config, eventId };
}

export async function analyzeEventImage(base64Image: string, mimeType: string) {
  // We import 'b' dynamically to avoid build crashes if sdk not fully set up
  const { b } = await import("@/lib/baml_client/baml_client");
  const { Image } = await import("@boundaryml/baml");

  const bamlImage = Image.fromBase64(mimeType, base64Image);
  const result = await b.ExtractEventDetails(bamlImage);
  
  return result;
}
