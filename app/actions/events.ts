"use server";

import crypto from "node:crypto";
// import { b as baml } from "@/lib/baml_client/baml_client";
import { EventAppConfig, EventGoal } from "@/lib/types";
import { rhizClient } from "@/lib/rhizClient";
import // retryWithBackoff,
// withTimeout,
"@/lib/errorHandling";
import { db } from "@/lib/db";
import { events } from "@/lib/db/schema";

// Deterministic hash to keep event + identity IDs stable across retries
const stableHash = (input: string) =>
  crypto.createHash("sha256").update(input).digest("hex").slice(0, 12);

/**
 * Generate event configuration with comprehensive error handling
 * Includes: validation, retry logic, timeout protection, and typed errors
 */
export async function generateEventConfig(
  formData: FormData
): Promise<{
  success: boolean;
  data?: EventAppConfig & { eventId: string };
  error?: string;
}> {
  const eventBasics = (formData.get("eventBasics") as string) || "";
  const eventDate = (formData.get("eventDate") as string) || "";
  const eventLocation = (formData.get("eventLocation") as string) || "";
  const goalsStr = (formData.get("goals") as string) || "";
  const goals = goalsStr
    .split(",")
    .map((s) => s.trim())
    .filter(Boolean);
  const audience = (formData.get("audience") as string) || "General Audience";
  const relationshipIntent =
    (formData.get("relationshipIntent") as string) || "medium";
  const tone = (formData.get("tone") as string) || "professional";

  // Extract and validate Event Type
  const rawType = formData.get("type") as string;
  const eventType =
    rawType === "lite" || rawType === "architect" ? rawType : "architect";
  const explicitEventName = (formData.get("eventName") as string) || "";

  try {
    // Validate required fields
    if (
      eventType === "architect" &&
      (!eventBasics || eventBasics.length < 10)
    ) {
      return {
        success: false,
        error: "Please describe your event in more detail (10+ chars)",
      };
    }
    if (eventType === "lite" && !explicitEventName) {
      return { success: false, error: "Event Name is required" };
    }

    if (!eventDate) {
      return { success: false, error: "Event date is required" };
    }

    if (!eventLocation) {
      return { success: false, error: "Event location is required" };
    }

    if (goals.length === 0) {
      return { success: false, error: "At least one goal is required" };
    }

    console.log("Generating config with inputs:", {
      type: eventType,
      eventBasics: eventBasics.substring(0, 50) + "...",
      eventDate,
      eventLocation,
      goals,
      audience,
      relationshipIntent,
      tone,
    });

    // ---------------------------------------------------------
    // REAL AI GENERATION via BAML
    // ---------------------------------------------------------
    
    // We import 'b' dynamically to avoid build crashes if sdk not fully set up
    const { b } = await import("@/lib/baml_client/baml_client");
    
    const bamlResult = await b.GenerateEventAppConfig(
      eventBasics || explicitEventName,
      eventDate,
      eventLocation,
      goals,
      audience,
      relationshipIntent,
      "standard", // sessionShape
      "high",     // matchmakingAppetite
      "standard", // tools
      tone
    );

    // Transform BAML result to Application Type
    const config: EventAppConfig = {
      id: "gen_" + Math.random().toString(36).substring(7),
      eventId: "evt_" + Math.random().toString(36).substring(7),
      version: 1,
      createdAt: new Date(),
      updatedAt: new Date(),
      attendeeProfileFields: [], // Defaults
      primaryGoals: bamlResult.primaryGoals as EventGoal[],
      matchmakingConfig: {
        ...bamlResult.matchmakingConfig,
        // Ensure numbers are numbers
        meetingDurations: bamlResult.matchmakingConfig.meetingDurations.map(Number)
      },
      sessionConfig: {
        ...bamlResult.sessionConfig,
         maxConcurrentSessions: Number(bamlResult.sessionConfig.maxConcurrentSessions)
      },
      engagementConfig: bamlResult.engagementConfig,
      relationshipFeatures: bamlResult.relationshipFeatures,
      branding: bamlResult.branding,
      designNotes: bamlResult.designNotes,
      
      // Default / Stubbed Fields (not generated by BAML yet)
      ticketing: {
        registrationOpen: true,
        skus: []
      },
      venueConstraints: {
        maxCapacity: 500,
        roomConstraints: {},
        accessibilityFeatures: []
      },
      sponsors: {
        tiers: [],
        assets: {}
      },
      legal: {
         photoConsentRequired: true
      },
      contentGuardrails: {
        brandVoiceGuidelines: "",
        tabooTopics: [],
        sensitiveTopics: []
      },

      content: {
        eventName: bamlResult.content.eventName,
        tagline: bamlResult.content.tagline,
        date: bamlResult.content.date,
        location: bamlResult.content.location,
        speakers: bamlResult.content.speakers.map(s => ({
            ...s,
            did: `did:rhiz:${s.name.replace(/\s+/g, '').toLowerCase()}`,
            handle: s.name.replace(/\s+/g, '').toLowerCase()
        })),
        schedule: bamlResult.content.schedule.map(s => ({
            ...s,
            eventId: "evt1", // temp
            startTime: new Date(), // Mock date since BAML gives string time
            endTime: new Date(),
            format: s.isWide ? 'keynote' : 'session',
            speakers: [s.speakerName]
        })),
        sampleAttendees: bamlResult.content.sampleAttendees.map(a => ({
            person_id: a.id || `p_${Math.random()}`,
            owner_id: "system",
            legal_name: a.name,
            tags: a.interests,
            imageFromUrl: a.imageUrl,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString(),
            emails: [],
            phones: [],
            social_handles: {}
        }))
      }
    };

    // MERGE USER INPUTS (Override defaults if needed)
    if (explicitEventName) {
        if (config.content) config.content.eventName = explicitEventName;
    }

    // Generate stable ID
    const eventFingerprint = `${eventBasics}|${eventDate}|${eventLocation}|${goals.join(
      ","
    )}|${audience}|${tone}`;
    const eventId = `event_${stableHash(eventFingerprint)}`;
    
    // Update IDs
    config.eventId = eventId;
    if (config.content) {
        config.content.schedule.forEach(s => s.eventId = eventId);
    }

    console.log("Successfully generated event config via BAML. Event ID:", eventId);

    // Save to Database
    try {
      if (process.env.DATABASE_URL || process.env.POSTGRES_URL) {
        await db.insert(events).values({
          slug: eventId,
          name: config.content?.eventName || "Untitled Event",
          config: config as unknown,
          type: eventType, // Save the selected mode
          ownerId: "demo-user",
          status: "draft",
          updatedAt: new Date(),
        });
        console.log("DB: Saved event", eventId);
      }
    } catch (dbError) {
      console.error("DB: Failed to save event (non-fatal)", dbError);
    }

    // Sync with Rhiz Protocol
    // 1. Sync Attendees
    if (
      config.content?.sampleAttendees &&
      config.content.sampleAttendees.length > 0
    ) {
      try {
        const result = await rhizClient.ingestAttendees({
          eventId,
          attendees: config.content.sampleAttendees.map((a) => ({
            id: a.person_id,
            name: a.legal_name || a.preferred_name || "Unknown",
            email: a.emails?.[0],
            tags: a.tags,
            avatarUrl: a.imageFromUrl,
          })),
        });

        // Merge back handles
        config.content.sampleAttendees = config.content.sampleAttendees.map(
          (a) => {
            const synced = result.attendees.find((r) => r.id === a.person_id);
            if (synced) {
              return { ...a, handle: synced.handle, did: synced.did };
            }
            return a;
          }
        );
      } catch (err) {
        console.error("Rhiz: Failed to sync attendees", err);
      }
    }

    // 2. Sync Speakers
    if (config.content?.speakers) {
      try {
        const speakerAttendees = config.content.speakers.map((s) => ({
          id: s.handle,
          name: s.name,
          tags: ["Speaker", s.role],
        }));

        const result = await rhizClient.ingestAttendees({
          eventId,
          attendees: speakerAttendees,
        });

        result.attendees.forEach((r, i) => {
          if (
            config.content &&
            config.content.speakers &&
            config.content.speakers[i]
          ) {
            config.content.speakers[i].handle =
              r.handle || config.content.speakers[i].handle;
            config.content.speakers[i].did =
              r.did || config.content.speakers[i].did;
          }
        });
      } catch (err) {
        console.error("Rhiz: Failed to sync speakers", err);
      }
    }

    // 3. Sync Sessions
    if (config.content?.schedule) {
      await rhizClient.ingestSessions({
        eventId,
        sessions: config.content.schedule,
      });
    }

    return { success: true, data: { ...config, eventId } };
  } catch (error: unknown) {
    // Catch ALL errors and return them safely to the client
    console.error("Server Action Error:", error);
    const message =
      error instanceof Error ? error.message : "An unexpected error occurred";
    return { success: false, error: message };
  }
}

/**
 * Update existing event configuration (for live edit mode)
 */
export async function updateEventConfig(
  eventId: string,
  updates: Partial<EventAppConfig>
) {
  // TODO: Implement when adding data persistence
  console.log("Update event config:", eventId, updates);
}

/**
 * Extract event details from an uploaded image using Gemini
 */
export async function extractDetailsFromImage(formData: FormData) {
  try {
    const file = formData.get("file") as File;
    if (!file) {
      throw new Error("No file uploaded");
    }

    if (file.size > 4 * 1024 * 1024) {
      throw new Error("File size too large (max 4MB)");
    }

    // Convert file to base64
    const arrayBuffer = await file.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);
    const base64Image = buffer.toString("base64");
    const mimeType = file.type || "image/jpeg";

    // Dynamic import to ensure BAML is ready
    const { b } = await import("@/lib/baml_client/baml_client");
    const { Image } = await import("@boundaryml/baml");

    console.log("Extracting details from image via Gemini...", mimeType);
    
    // Pass image to BAML
    // Note: detailed implementation depends on specific BAML TS client interface for images
    // Usually it accepts { base64: string, media_type: string } or similar wrapper
    const bamlImage = Image.fromBase64(mimeType as string, base64Image);

    const result = await b.ExtractEventDetails(bamlImage);

    console.log("Extraction complete:", result);
    return { success: true, data: result };

  } catch (error) {
    console.error("Image extraction failed:", error);
    return { 
      success: false, 
      error: error instanceof Error ? error.message : "Failed to analyze image" 
    };
  }
}

